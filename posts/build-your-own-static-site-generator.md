---
title: "Build your own static site generator (because why not?)"
date: "2019-06-01"
public: true
tags:
  - tutorial
  - nodejs
---

Maybe you're like me and believe in the instrinsic value of blogging, but
struggle to keep one going, often giving up after succumbing to anxiety stemming
from imposter syndrome.

Well, perhaps building your own blogging platform from scratch (_or writing
a guide on how to do so_) will give you the motivation you need to keep it up
this time.

In this guide I'll walk you through the steps of building your own **static site
generator** (SSG) using the following components:

* **[Node.js](https://nodejs.org/en/)** - minimum version 12.x ⚠️
* **[Markdown](https://daringfireball.net/projects/markdown/)** - a sensible markup language to write posts in.
* **[Netlify](https://www.netlify.com/)** - a superb static site host provider.

<br>

## Why build your own?

Time to address the elephant in the room; there are an
[almost](https://jekyllrb.com) [endless](https://gohugo.io) [list](https://hexo.io)
[of](https://blog.getpelican.com) [fantastic](https://www.gatsbyjs.org/),
ready-to-use SSGs out there. Why should you build your own?

<img alt="but why?" class="meme" width="250" src="https://media.giphy.com/media/s239QJIh56sRW/giphy.gif">

While those SSGs are indeed rich in features, they can be overkill for some users.
Building your own also means you can avoid installing (and maintaining) a 3rd
party client. However, I believe to gain an understanding of the inner workings
of an SSG is the most beneficial reason of all.

<br>

## Overview

These are the core concepts outlined in this guide:

1. [Create HTML templates](#create-html-templates)
2. [Create a new post](#create-a-new-post)
3. [Retrieve the posts](#retrieve-the-posts)
4. [Convert Markdown to HTML](#convert-markdown-to-html)
5. [Generate HTML files](#generate-html-files)
6. [Run the generator](#run-the-generator)
7. [Deploy to Netlify](#deploy-to-netlify)
8. [Final thoughts](#final-thoughts)

If you'd like, you can skip straight to the
[GitHub repo](https://github.com/izolate/static-site-generator) for this guide.

### Folder structure

```bash
.
├── index.js
├── posts/
│   ├── hello-world.md
├── public/
│   └── hello-world.html
└── templates/
    ├── base.njk
    ├── post.njk
    └── index.njk
```

* `index.js` contains the application logic.
* `posts` directory contains the blog posts written in Markdown.
* `public` directory contains the generated HTML files. Everything in this directory will be publicly-accessible, so it's a good place to store assets like images and CSS too.
* `templates` directory contains the templates used to generate the HTML files.

<br>

## Create HTML templates

As the name suggests, the purpose of a static site generator is to generate
HTML pages. For our purpose, we need a page for every blog post, and one index
page with links to all posts.

The HTML markup for these pages adheres to a common structure derived from a
starting template, and is generated by a templating engine. We'll use Mozilla's
**[Nunjucks](https://mozilla.github.io/nunjucks/)**, due to its syntax being
the most similar to HTML, but other options include [EJS](https://ejs.co/),
[Handlebars](http://handlebarsjs.com) or [Pug](https://pugjs.org) (a personal favourite).

We require 3 templates; one parent template and two child templates for the
post and index pages. Create the template directory and 3 Nunjuck (`.njk`) files
inside. 

```bash
# Create a directory for templates
mkdir -p templates

# Create the template files
touch templates/base.njk \
      templates/post.njk \
      templates/index.njk
```

### Base template
The parent template includes the generic, top-level structure of the HTML page.
It contains two modular blocks, for the head and body, that can be edited from
any child templates.

Save the following content inside `base.njk`.

```html
<!doctype html>
<html lang="en">
  <head>
    {% block header %}
    <meta charset="utf-8">
    <meta description="{{ description | default('Build your own static site generator') }}">
    <title>{{ title | default('Blog')}}</title>
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/modern-normalize/0.5.0/modern-normalize.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/github-markdown-css/3.0.1/github-markdown.min.css">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    {% endblock %}
  </head>
  <body>
    {% block body %}{% endblock %}
  </body>
</html>
```

The [default filter](https://mozilla.github.io/nunjucks/templating.html#default-value-default-boolean)
is used to create a site title and description in the absence of one,
while the linked stylesheets add some basic styling to the rendered HTML,
making it a bit more readable.

### Post template
This extends from the base template and renders the markup for the post
content within the body block.

Save the following content inside `post.njk`.

```html
{% extends "./base.njk" %}

{% block body %}
  <article>
    <header>
      <h1>{{ title }}</h1>
    </header>
    <div class="markdown-body">
      {{ body | safe }}
    </div>
  </article>

  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/highlight.min.js"></script>
  <script>window.hljs.initHighlightingOnLoad();</script>
 {% endblock %}
```

Since the variable `body` contains the post content in pure HTML, the
[safe filter](https://mozilla.github.io/nunjucks/templating.html#safe)
is needed to prevent the template engine from escaping the HTML tags.

The scripts initialize [highlight.js](https://highlightjs.org/) to provide
syntax highlighting for code blocks. The class `.markdown-body` is required
to allow this to work. 

### Index template

This also extends from the base template, and features a list of links to
posts that were generated.

Save the following content inside `index.njk`.

```html
{% extends "./base.njk" %}

{% block body %}
  <section>
    <header>
      <h1>Blog</h1>
    </header>

    <ol>
    {% for post in posts %}
      <li>
        <a href="{{ post.slug }}">{{ post.title }}</a>
      </li>
    {% endfor %}
    </ol>
  <section>
{% endblock %}
```

<br>

## Create a new post

All posts are saved inside a posts directory, so start off by creating that.

```bash
mkdir -p posts
```

### Markdown

Like most static site generators, our posts will be written in Markdown. It's a
minimalistic markup language that's well-suited to writing articles and easily
converts to HTML. If you aren't already familiar with it, I recommend reading
[this guide](https://learnxinyminutes.com/docs/markdown/) to learn more.

### Front matter

Given that SSGs don't have a database the way traditional blogging platforms do,
the post metadata (title, author, public date, etc.) is stored in the post itself;
the top part of the file contains a block of [YAML](https://yaml.org/) config
representing this data.

This is called the **front matter**, an idea shamelessly borrowed from
[Jekyll](https://jekyllrb.com/docs/front-matter/).

Post metadata is consumed by the HTML templates to populate HTML tags,
and also by the generator to manage the posts.

### Choosing a file name

It's important to choose an appropriate file name when you create a new post.
The file name you choose will be re-used for the final HTML file,
so you should try to make it URL-friendly by slugifying the post title.

For example, save the following file in the posts directory as
`dogs-are-better-than-cats.md`:

```md
---
title: "Dogs are better than cats"
description: "Study concludes that dogs make better pets than cats."
date: "2019-06-01"
public: true
---

A new scientific [study](https://example.com/science.php) by the
**University of Fake News**, concluded this week that man's best friend
are objectively superior pets.

The study, which compared dogs to cats across several qualities ranging from
emotional intelligence to loyalty, is bound to add more heat to the endless
debate between dog owners and cat ~~slaves~~ owners.
```

⚠️ Remember to use this post template for any subsequent posts that you make.

<br>

## Retrieve the posts

To retrieve the Markdown files in the posts directory, we need to first assemble
a list of all the files in the directory, and then read the contents of each
file in turn, skipping over any sub-directories, or files that don't match an
`.md` extension.

The standard [File System](https://nodejs.org/api/fs.html) module in Node.js
makes working with files easy. We can use it to create a generic method to
list all files in a directory that match a certain file extension:

```javascript
const fs = require('fs').promises;

/**
 * getFiles returns a list of all files in a directory path {dirPath}
 * that match a given file extension {fileExt} (optional).
 */
const getFiles = async (dirPath, fileExt = '') => {
  // List all the entries in the directory.
  const dirents = await fs.readdir(dirPath, { withFileTypes: true });

  return (
    dirents
      // Omit any sub-directories.
      .filter(dirent => dirent.isFile())
      // Ensure the file extension matches a given extension (optional).
      .filter(dirent =>
        fileExt.length ? dirent.name.toLowerCase().endsWith(fileExt) : true
      )
      // Return a list of file names.
      .map(dirent => dirent.name)
  );
};
```

We used the `fs.promises` API to provide an alternate set of methods that
return Promises rather than using callbacks.

The `withFileTypes` option provided to `fs.readdir` makes it return a list of 
[fs.Dirents](https://nodejs.org/api/fs.html#fs_class_fs_dirent) objects instead
of strings. These objects contain useful file validation methods based on the
data provided by [libuv](https://libuv.org/) (the low-level C library that
Node.js relies on for asynchronous I/O).

Still, the validation methods do have limitations, so we have to manually check
the file extension matches.

### Get all posts in directory

Using the generic `getFiles()` method, we can create a posts retrieval method,
responsible for reading all the files in the posts directory, and returning a
list of post objects after parsing the file content(s).

```javascript
const fs = require('fs').promises;
const path = require('path');

/**
 * getPosts lists and reads all the Markdown files in the posts directory,
 * returning a list of post objects after parsing the file contents.
 */
const getPosts = async dirPath => {
  // Get a list of all Markdown files in the directory.
  const fileNames = await getFiles(dirPath, '.md');

  // Create a list of files to read.
  const filesToRead = fileNames.map(fileName =>
    fs.readFile(path.resolve(dirPath, fileName), 'utf-8')
  );

  // Asynchronously read all the file contents.
  const fileData = await Promise.all(filesToRead);

  return fileNames.map((fileName, i) => parsePost(fileName, fileData[i]));
};
```

In the return statement, our intention to return a list of normalized objects
is pretty clear. In the next step, we'll create a method to parse the post file
content into a post object.

### Parse the post content

We require a method to read the file content and return the data in a nicer format,
specifically a post object that resembles:

```json
{
  "title": "Dogs are better than cats.",
  "description": "Study concludes that dogs make better pets than cats.",
  "slug": "dogs-are-better-than-cats",
  "date": "2019-06-01",
  "public": true,
  "body": "A new scientific [study](https://example.com/science.php)"
}
```

Thankfully, we don't have to manually parse the file content to separate the front
matter from the post content. We can rely on the [front-matter](https://www.npmjs.com/package/front-matter)
package from NPM to do the heavy lifting for us 💯.

```javascript
const frontMatter = require('front-matter');

/**
 * parsePost consumes the file name and file content and returns a post
 * object with separate front matter (meta), post body and slug.
 */
const parsePost = (fileName, fileData) => {
  // Strip the extension from the file name to get a slug.
  const slug = path.basename(fileName, '.md');
  // Split the file content into the front matter (attributes) and post body.
  const { attributes, body } = frontMatter(fileData);

  return { ...attributes, body, slug };
};
```

<br>

## Convert Markdown to HTML

We need a method that consumes Markdown text and converts it to HTML using a
Markdown-to-HTML compiler (from NPM).

The NPM package ecosystem being as extensive as it is, offers several compilers.
The lines between these libraries can often blur, making it an arduous task in
itself to choose the right one. Ultimately, trial and error remains the best
approach to figuring out which one to use.

Based on my findings, I chose **[remark.js](https://remark.js.org/)**
because it's pluggable, seems actively maintained, and has shown a
[positive growth](https://www.npmtrends.com/markdown-it-vs-remark-vs-remarkable)
trend 📈.

```javascript
const remark = require('remark');
const remarkHTML = require('remark-html');
const remarkSlug = require('remark-slug');
const remarkHighlight = require('remark-highlight.js');

/**
 * markdownToHTML converts Markdown text to HTML.
 * Adds links to headings, and code syntax highlighting.
 */
const markdownToHTML = text =>
  new Promise((resolve, reject) =>
    remark()
      .use(remarkHTML)
      .use(remarkSlug)
      .use(remarkHighlight)
      .process(text, (err, file) =>
        err ? reject(err) : resolve(file.contents)
      )
  );
```

This method is wrapped in a Promise to avoid the awkward callback-style API.

### Remark plugins

Remark has a rich [plugin ecosystem](https://github.com/remarkjs/remark/blob/master/doc/plugins.md#list-of-plugins)
to add additional features to the parser. This guide uses the absolute minimum
set that a tech blog would require, but feel free to experiment with others.

* [remark-html](https://www.npmjs.com/package/remark-html) - converts Markdown to HTML.
* [remark-slug](https://www.npmjs.com/package/remark-slug) - creates linkable IDs for headings.
* [remark-highlight.js](https://www.npmjs.com/package/remark-highlight.js) - adds code syntax highlighting.

<br>

## Generate HTML files

We need to create two methods; one for generating the files for blog posts, and
the other to generate the index page.

Both methods will need a way to retrieve their associated Nunjuck HTML templates, so we can also create a helper method to resolve template file paths.

```javascript
const path = require('path');

// getTemplatePath creates a file path to an HTML template file.
const getTemplatePath = name =>
  path.resolve(__dirname, 'templates', path.format({ name, ext: '.njk' }));
```

### Generate post files

The following method generates the HTML file for a blog post and saves it to the
public directory. It consumes the post object created by the `parsePost()` method.

```javascript
const fs = require('fs').promises;
const path = require('path');
const nunjucks = require('nunjucks');

// Store a reference path to the destination directory.
const publicDirPath = path.resolve(__dirname, 'public');

/**
 * createPostFile generates a new HTML page from a template and saves the file.
 * It also converts the post body from Markdown to HTML.
 */
const createPostFile = async post => {
  // Use the template engine to generate the file content.
  const fileData = nunjucks.render(getTemplatePath('post'), {
    ...post,
    // Convert Markdown to HTML.
    body: await markdownToHTML(post.body)
  });

  // Combine the slug and file extension to create a file name.
  const fileName = path.format({ name: post.slug, ext: '.html' });
  // Create a file path in the destination directory.
  const filePath = path.resolve(publicDirPath, fileName);

  // Save the file in the desired location.
  await fs.writeFile(filePath, fileData, 'utf-8');

  return post;
};
```

### Generate index file

The following method consumes a list of post objects and generates the HTML
file for the index page, saving it in the public directory as `index.html`.

```javascript
const fs = require('fs').promises;
const path = require('path');

// Store a reference path to the destination directory.
const publicDirPath = path.resolve(__dirname, 'public');

/**
 * createIndexFile generates an index file with a list of blog posts.
 */
const createIndexFile = async posts => {
  // Use the template engine to generate the file content.
  const fileData = nunjucks.render(getTemplatePath('index'), { posts });
  // Create a file path in the destination directory.
  const filePath = path.resolve(publicDirPath, 'index.html');

  // Save the file in the desired location.
  await fs.writeFile(filePath, fileData, 'utf-8');
};
```

### Remove existing files

Each time the generator is run, the public directory should be populated with
the HTML files from that build session only. This is required to allow posts to
be made private once set public.

For this reason, we need to clear the public directory of any HTML files in
order to generate a fresh batch each time. We can re-use the generic `getFiles()`
method created previously to construct a method to empty the public directory
by deleting any files that match a file extension.

```javascript
const fs = require('fs').promises;
const path = require('path');

// removeFiles deletes all files in a directory that match a file extension.
const removeFiles = async (dirPath, fileExt) => {
  // Get a list of all files in the directory.
  const fileNames = await getFiles(dirPath, fileExt);

  // Create a list of files to remove.
  const filesToRemove = fileNames.map(fileName =>
    fs.unlink(path.resolve(dirPath, fileName))
  );

  return Promise.all(filesToRemove);
};
```

<br>

## Run the generator

There are a few steps remainging before we can finish the codebase; we need to
create a method to run the generator, then initialize the Node.js project and
install dependencies.

### Create a main method

We need to create a method that runs the generator in its entireity, and glues
together all of the other methods that we created in this guide.

```javascript
const fs = require('fs').promises;
const path = require('path');

// Store a reference to the source directory.
const postsDirPath = path.resolve(__dirname, 'posts');
// Store a reference path to the destination directory.
const publicDirPath = path.resolve(__dirname, 'public');

// build runs the static site generator.
const build = async () => {
  // Delete any previously-generated HTML files in the public directory.
  await removeFiles(publicDirPath, '.html');

  // Get all the Markdown files in the posts directory.
  const posts = await getPosts(postsDirPath);

  // Generate pages for all posts that are public.
  const postsToCreate = posts
    .filter(post => Boolean(post.public))
    .map(post => createPostFile(post));

  const createdPosts = await Promise.all(postsToCreate);

  // Generate a page with a list of posts.
  await createIndexFile(
    // Sort created posts by publish date (newest first).
    createdPosts.sort((a, b) => new Date(b.date) - new Date(a.date))
  );

  return createdPosts;
};
```

Finally, we can run the build method, catching and logging any errors that
the generator produces downstream, since they will bubble up into this method.

```javascript
build()
  .then(created =>
    console.log(`Build successful. Generated ${created.length} post(s).`)
  )
  .catch(err => console.error(err));
```

### Create the `index.js` file

```bash
# create index file
touch index.js
```

Save the following content in the project's root directory in a file called
`index.js`. This is the final file that combines all of the other methods that
we covered in this guide.

```javascript
const fs = require('fs').promises;
const path = require('path');
const frontMatter = require('front-matter');
const remark = require('remark');
const remarkHTML = require('remark-html');
const remarkSlug = require('remark-slug');
const remarkHighlight = require('remark-highlight.js');
const nunjucks = require('nunjucks');

// Store a reference to the source directory.
const postsDirPath = path.resolve(__dirname, 'posts');
// Store a reference path to the destination directory.
const publicDirPath = path.resolve(__dirname, 'public');

/**
 * getFiles returns a list of all files in a directory path {dirPath}
 * that match a given file extension {fileExt} (optional).
 */
const getFiles = async (dirPath, fileExt = '') => {
  // List all the entries in the directory.
  const dirents = await fs.readdir(dirPath, { withFileTypes: true });

  return (
    dirents
      // Omit any sub-directories.
      .filter(dirent => dirent.isFile())
      // Ensure the file extension matches a given extension (optional).
      .filter(dirent =>
        fileExt.length ? dirent.name.toLowerCase().endsWith(fileExt) : true
      )
      // Return a list of file names.
      .map(dirent => dirent.name)
  );
};

// removeFiles deletes all files in a directory that match a file extension.
const removeFiles = async (dirPath, fileExt) => {
  // Get a list of all files in the directory.
  const fileNames = await getFiles(dirPath, fileExt);

  // Create a list of files to remove.
  const filesToRemove = fileNames.map(fileName =>
    fs.unlink(path.resolve(dirPath, fileName))
  );

  return Promise.all(filesToRemove);
};

/**
 * parsePost consumes the file name and file content and returns a post
 * object with separate front matter (meta), post body and slug.
 */
const parsePost = (fileName, fileData) => {
  // Strip the extension from the file name to get a slug.
  const slug = path.basename(fileName, '.md');
  // Split the file content into the front matter (attributes) and post body.
  const { attributes, body } = frontMatter(fileData);

  return { ...attributes, body, slug };
};

/**
 * getPosts lists and reads all the Markdown files in the posts directory,
 * returning a list of post objects after parsing the file contents.
 */
const getPosts = async dirPath => {
  // Get a list of all Markdown files in the directory.
  const fileNames = await getFiles(dirPath, '.md');

  // Create a list of files to read.
  const filesToRead = fileNames.map(fileName =>
    fs.readFile(path.resolve(dirPath, fileName), 'utf-8')
  );

  // Asynchronously read all the file contents.
  const fileData = await Promise.all(filesToRead);

  return fileNames.map((fileName, i) => parsePost(fileName, fileData[i]));
};

/**
 * markdownToHTML converts Markdown text to HTML.
 * Adds links to headings, and code syntax highlighting.
 */
const markdownToHTML = text =>
  new Promise((resolve, reject) =>
    remark()
      .use(remarkHTML)
      .use(remarkSlug)
      .use(remarkHighlight)
      .process(text, (err, file) =>
        err ? reject(err) : resolve(file.contents)
      )
  );

// getTemplatePath creates a file path to an HTML template file.
const getTemplatePath = name =>
  path.resolve(__dirname, 'templates', path.format({ name, ext: '.njk' }));

/**
 * createPostFile generates a new HTML page from a template and saves the file.
 * It also converts the post body from Markdown to HTML.
 */
const createPostFile = async post => {
  // Use the template engine to generate the file content.
  const fileData = nunjucks.render(getTemplatePath('post'), {
    ...post,
    // Convert Markdown to HTML.
    body: await markdownToHTML(post.body)
  });

  // Combine the slug and file extension to create a file name.
  const fileName = path.format({ name: post.slug, ext: '.html' });
  // Create a file path in the destination directory.
  const filePath = path.resolve(publicDirPath, fileName);

  // Save the file in the desired location.
  await fs.writeFile(filePath, fileData, 'utf-8');

  return post;
};

/**
 * createIndexFile generates an index file with a list of blog posts.
 */
const createIndexFile = async posts => {
  // Use the template engine to generate the file content.
  const fileData = nunjucks.render(getTemplatePath('index'), { posts });
  // Create a file path in the destination directory.
  const filePath = path.resolve(publicDirPath, 'index.html');

  // Save the file in the desired location.
  await fs.writeFile(filePath, fileData, 'utf-8');
};

// build runs the static site generator.
const build = async () => {
  // Delete any previously-generated HTML files in the public directory.
  await removeFiles(publicDirPath, '.html');

  // Get all the Markdown files in the posts directory.
  const posts = await getPosts(postsDirPath);

  // Generate pages for all posts that are public.
  const postsToCreate = posts
    .filter(post => Boolean(post.public))
    .map(post => createPostFile(post));

  const createdPosts = await Promise.all(postsToCreate);

  // Generate a page with a list of posts.
  await createIndexFile(
    // Sort created posts by publish date.
    createdPosts.sort((a, b) => new Date(a.date) - new Date(b.date))
  );

  return createdPosts;
};

build()
  .then(created =>
    console.log(`Build successful. Generated ${created.length} post(s).`)
  )
  .catch(err => console.error(err));
```

### Initialize project

Create a new Node.js project with NPM, following the steps in the command line
to initialize the project:

```bash
npm init
```

Next, install the project's external dependencies:

```bash
npm install front-matter \
            remark \
            remark-html \
            remark-slug \
            remark-highlight.js \
            nunjucks
```

### Create build scripts

Add the following scripts object to your project's `package.json` file:

```json
"scripts": {
    "build": "node .",
    "start": "npm run build && serve ./public"
}
```

Install the dependencies for development:

```bash
npm install --save-dev serve
```

<img alt="Blog post screenshot" class="meme" width="300" src="/assets/img/ssg-blog-post.png">

<br>

## Deploy to Netlify

<br>

## Final thoughts
By using some native Node.js modules and packages from NPM, we were able to
create a minimal static site generator. In the process we learnt a bit about
how SSGs work.


